#pragma once

////
//
//      STM32MP1 FDCAN1 peripherals
//
////

////
//
//      FDCAN1
//
////

struct stm32mp15xxx_fdcan1_t
{
    volatile uint32_t FDCAN_CREL;   // [read-only] FDCAN core release register
    volatile uint32_t FDCAN_ENDN;   // [read-only] FDCAN Endian register
    reserved_t<0x1> _0xc;
    volatile uint32_t FDCAN_DBTP;   // [read-write] This register is dedicated to data bit timing phase and only writable if bits FDCAN_CCCR.CCE and FDCAN_CCCR.INIT are set. The CAN time quantum may be programmed in the range from 1 to 32 FDCAN clock periods. tq = (DBRP + 1) FDCAN clock periods. DTSEG1 is the sum of Prop_Seg and Phase_Seg1. DTSEG2 is Phase_Seg2. Therefore the length of the bit time is (DTSEG1 + DTSEG2 + 3) tq for programmed values, or (Sync_Seg+Prop_Seg+Phase_Seg1+Phase_Seg2) tq for functional values. The information processing time (IPT) is zero, meaning the data for the next bit is available at the first clock edge after the sample point.
    volatile uint32_t FDCAN_TEST;   // Write access to this register has to be enabled by setting bit FDCAN_CCCR.TEST to 1. All register functions are set to their reset values when bit FDCAN_CCCR.TEST is reset. Loop back mode and software control of Tx pin FDCANx_TX are hardware test modes. Programming TX differently from 00 may disturb the message transfer on the CAN bus.
    volatile uint32_t FDCAN_RWD;    // The RAM watchdog monitors the READY output of the message RAM. A message RAM access starts the message RAM watchdog counter with the value configured by the FDCAN_RWD.WDC bits. The counter is reloaded with FDCAN_RWD.WDC bits when the message RAM signals successful completion by activating its READY output. In case there is no response from the message RAM until the counter has counted down to 0, the counter stops and interrupt flag FDCAN_IR.WDI bit is set. The RAM watchdog counter is clocked by the fdcan_pclk clock.
    volatile uint32_t FDCAN_CCCR;   // For details about setting and resetting of single bits see Software initialization.
    volatile uint32_t FDCAN_NBTP;   // [read-write] This register is dedicated to the nominal bit timing used during the arbitration phase.
    volatile uint32_t FDCAN_TSCC;   // [read-write] FDCAN timestamp counter configuration register
    volatile uint32_t FDCAN_TSCV;   // [read-write] FDCAN timestamp counter value register
    volatile uint32_t FDCAN_TOCC;   // [read-write] FDCAN timeout counter configuration register
    volatile uint32_t FDCAN_TOCV;   // [read-write] FDCAN timeout counter value register
    reserved_t<0x4> _0x40;
    volatile uint32_t FDCAN_ECR;    // FDCAN error counter register
    volatile uint32_t FDCAN_PSR;    // FDCAN protocol status register
    volatile uint32_t FDCAN_TDCR;   // [read-write] FDCAN transmitter delay compensation register
    reserved_t<0x1> _0x50;
    volatile uint32_t FDCAN_IR;     // [read-write] The flags are set when one of the listed conditions is detected (edge-sensitive). The flags remain set until the Host clears them. A flag is cleared by writing a 1 to the corresponding bit position. Writing a 0 has no effect. A hard reset will clear the register. The configuration of IE controls whether an interrupt is generated. The configuration of ILS controls on which interrupt line an interrupt is signaled.
    volatile uint32_t FDCAN_IE;     // [read-write] The settings in the interrupt enable register determine which status changes in the interrupt register will be signaled on an interrupt line.
    volatile uint32_t FDCAN_ILS;    // [read-write] This register assigns an interrupt generated by a specific interrupt flag from the interrupt register to one of the two module interrupt lines. For interrupt generation the respective interrupt line has to be enabled via FDCAN_ILE.EINT0 and FDCAN_ILE.EINT1.
    volatile uint32_t FDCAN_ILE;    // [read-write] Each of the two interrupt lines to the CPU can be enabled/disabled separately by programming bits EINT0 and EINT1.
    reserved_t<0x8> _0x80;
    volatile uint32_t FDCAN_GFC;    // [read-write] Global settings for message ID filtering. The global filter configuration register controls the filter path for standard and extended messages as described in Figure708: Standard message ID filter path and Figure709: Extended message ID filter path.
    volatile uint32_t FDCAN_SIDFC;  // [read-write] Settings for 11-bit standard message ID filtering.The standard ID filter configuration register controls the filter path for standard messages as described in Figure708.
    volatile uint32_t FDCAN_XIDFC;  // [read-write] Settings for 29-bit extended message ID filtering. The FDCAN extended ID filter configuration register controls the filter path for standard messages as described in Figure709: Extended message ID filter path.
    reserved_t<0x1> _0x90;
    volatile uint32_t FDCAN_XIDAM;  // [read-write] FDCAN extended ID and mask register
    volatile uint32_t FDCAN_HPMS;   // [read-only] This register is updated every time a message ID filter element configured to generate a priority event match. This can be used to monitor the status of incoming high priority messages and to enable fast access to these messages.
    volatile uint32_t FDCAN_NDAT1;  // [read-write] FDCAN new data 1 register
    volatile uint32_t FDCAN_NDAT2;  // [read-write] FDCAN new data 2 register
    volatile uint32_t FDCAN_RXF0C;  // [read-write] FDCAN Rx FIFO 0 configuration register
    volatile uint32_t FDCAN_RXF0S;  // [read-write] FDCAN Rx FIFO 0 status register
    volatile uint32_t FDCAN_RXF0A;  // [read-write] FDCAN Rx FIFO 0 acknowledge register
    volatile uint32_t FDCAN_RXBC;   // [read-write] FDCAN Rx buffer configuration register
    volatile uint32_t FDCAN_RXF1C;  // [read-write] FDCAN Rx FIFO 1 configuration register
    volatile uint32_t FDCAN_RXF1S;  // [read-only] FDCAN Rx FIFO 1 status register
    volatile uint32_t FDCAN_RXF1A;  // [read-write] FDCAN Rx FIFO 1 acknowledge register
    volatile uint32_t FDCAN_RXESC;  // [read-only] Configures the number of data bytes belonging to an Rx buffer / Rx FIFO element. Data field sizes higher than 8 bytes are intended for CAN FD operation only.
    volatile uint32_t FDCAN_TXBC;   // [read-write] FDCAN Tx buffer configuration register
    volatile uint32_t FDCAN_TXFQS;  // [read-only] The Tx FIFO/queue status is related to the pending Tx requests listed in register FDCAN_TXBRP. Therefore the effect of add/cancellation requests may be delayed due to a running Tx scan (FDCAN_TXBRP not yet updated).
    volatile uint32_t FDCAN_TXESC;  // [read-only] Configures the number of data bytes belonging to a Tx buffer element. Data field sizes &gt;8 bytes are intended for CAN FD operation only.
    reserved_t<0x1> _0xd0;
    volatile uint32_t FDCAN_TXBAR;  // [read-write] FDCAN Tx buffer add request register
    volatile uint32_t FDCAN_TXBCR;  // [read-write] FDCAN Tx buffer cancellation request register
    volatile uint32_t FDCAN_TXBTO;  // [read-only] FDCAN Tx buffer transmission occurred register
    volatile uint32_t FDCAN_TXBCF;  // [read-only] FDCAN Tx buffer cancellation finished register
    volatile uint32_t FDCAN_TXBTIE; // [read-write] FDCAN Tx buffer transmission interrupt enable register
    volatile uint32_t FDCAN_TXBCIE; // [read-write] FDCAN Tx buffer cancellation finished interrupt enable register
    reserved_t<0x2> _0xf0;
    volatile uint32_t FDCAN_TXEFC;  // [read-write] FDCAN Tx event FIFO configuration register
    volatile uint32_t FDCAN_TXEFS;  // [read-only] FDCAN Tx event FIFO status register
    volatile uint32_t FDCAN_TXEFA;  // [read-write] FDCAN Tx event FIFO acknowledge register
    reserved_t<0x1> _0x100;
    volatile uint32_t FDCAN_TTTMC;  // [read-write] FDCAN TT trigger memory configuration register
    volatile uint32_t FDCAN_TTRMC;  // [read-write] FDCAN TT reference message configuration register
    volatile uint32_t FDCAN_TTOCF;  // [read-write] FDCAN TT operation configuration register
    volatile uint32_t FDCAN_TTMLM;  // [read-write] FDCAN TT matrix limits register
    volatile uint32_t FDCAN_TURCF;  // [read-write] The length of the NTU is given by: NTU = CAN clock period x NC/DC. NC is an 18-bit value. Its high part, NCH[17:16] is hard wired to 0b01. Therefore the range of NC extends from 0x10000 to 0x1FFFF. The value configured by NCL is the initial value for FDCAN_TURNA.NAV[15:0]. DC is set to 0x1000 by hardware reset and it may not be written to 0x0000. Level 1: NC 4 * DC and NTU = CAN bit time Levels 0 and 2: NC 8 * DC The actual value of FDCAN_TUR may be changed by the clock drift compensation function of TTCAN level 0 and level 2 in order to adjust the node local view of the NTU to the time master view of the NTU. DC will not be changed by the automatic drift compensation, FDCAN_TURNA.NAV may be adjusted around NC in the range of the synchronization deviation limit given by FDCAN_TTOCF.LDSDL. NC and DC should be programmed to the largest suitable values in achieve the best computational accuracy for the drift compensation process.
    volatile uint32_t FDCAN_TTOCN;  // FDCAN TT operation control register
    volatile uint32_t FDCAN_TTGTP;  // [read-write] If TTOST.WGDT is set, the next reference message will be transmitted with the Master_Ref_Mark modified by the preset value and with Disc_Bit = 1, presetting the global time in all nodes simultaneously. TP is reset to 0x0000 each time a reference message with Disc_Bit = 1 becomes valid or if the node is not the current time master. TP is locked while FDCAN_TTOST.WGTD = 1 after setting FDCAN_TTOCN.SGT until the reference message with Disc_Bit = 1 becomes valid or until the node is no longer the current time master.
    volatile uint32_t FDCAN_TTTMK;  // A time mark interrupt (FDCAN_TTIR.TMI = 1) is generated when the time base indicated by FDCAN_TTOCN.TMC (cycle time, local time, or global time) has the same value as TM.
    volatile uint32_t FDCAN_TTIR;   // [read-write] The flags are set when one of the listed conditions is detected (edge-sensitive). The flags remain set until the Host clears them. A flag is cleared by writing a 1 to the corresponding bit position. Writing a 0 has no effect. A hard reset will clear the register.
    volatile uint32_t FDCAN_TTIE;   // [read-write] The settings in the TT interrupt enable register determine which status changes in the TT interrupt register will result in an interrupt.
    volatile uint32_t FDCAN_TTILS;  // [read-write] The TT interrupt Line select register assigns an interrupt generated by a specific interrupt flag from the TT interrupt register to one of the two module interrupt lines. For interrupt generation the respective interrupt line has to be enabled via FDCAN_ILE.EINT0 and FDCAN_ILE.EINT1.
    volatile uint32_t FDCAN_TTOST;  // [read-only] FDCAN TT operation status register
    volatile uint32_t FDCAN_TURNA;  // [read-only] There is no drift compensation in TTCAN level 1.
    volatile uint32_t FDCAN_TTLGT;  // [read-only] FDCAN TT local and global time register
    volatile uint32_t FDCAN_TTCTC;  // [read-only] FDCAN TT cycle time and count register
    volatile uint32_t FDCAN_TTCPT;  // [read-only] FDCAN TT capture time register
    volatile uint32_t FDCAN_TTCSM;  // [read-only] FDCAN TT cycle sync mark register
    reserved_t<0x6f> _0x300;
    volatile uint32_t FDCAN_TTTS;   // [read-write] The settings in the FDCAN_TTTS register select the input to be used as event trigger and stop watch trigger.

    static constexpr uint32_t FDCAN_CREL_RESET_VALUE = 0x32141218;
    template<uint32_t X>
    static constexpr uint32_t FDCAN_CREL_DAY =       // DAY
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_CREL_MON =       // MON
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_CREL_YEAR =      // YEAR
        bit_field_t<16, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_CREL_SUBSTEP =   // SUBSTEP
        bit_field_t<20, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_CREL_STEP =      // STEP
        bit_field_t<24, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_CREL_REL =       // REL
        bit_field_t<28, 0xf>::value<X>();

    static constexpr uint32_t FDCAN_ENDN_RESET_VALUE = 0x87654321;

    static constexpr uint32_t FDCAN_DBTP_RESET_VALUE = 0xa33;
    template<uint32_t X>
    static constexpr uint32_t FDCAN_DBTP_DSJW =          // DSJW
        bit_field_t<0, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_DBTP_DTSEG2 =        // DTSEG2
        bit_field_t<4, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_DBTP_DTSEG1 =        // DTSEG1
        bit_field_t<8, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_DBTP_DBRP =          // DBRP
        bit_field_t<16, 0x1f>::value<X>();
    static constexpr uint32_t FDCAN_DBTP_TDC = 0x800000; // TDC

    static constexpr uint32_t FDCAN_TEST_RESET_VALUE = 0x0;
    static constexpr uint32_t FDCAN_TEST_LBCK = 0x10; // LBCK
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TEST_TX =         // TX
        bit_field_t<5, 0x3>::value<X>();
    static constexpr uint32_t FDCAN_TEST_RX = 0x80;   // RX

    static constexpr uint32_t FDCAN_RWD_RESET_VALUE = 0x0;
    template<uint32_t X>
    static constexpr uint32_t FDCAN_RWD_WDC =   // WDC
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_RWD_WDV =   // WDV
        bit_field_t<8, 0xff>::value<X>();

    static constexpr uint32_t FDCAN_CCCR_RESET_VALUE = 0x1;
    static constexpr uint32_t FDCAN_CCCR_INIT = 0x1;    // INIT
    static constexpr uint32_t FDCAN_CCCR_CCE = 0x2;     // CCE
    static constexpr uint32_t FDCAN_CCCR_ASM = 0x4;     // ASM
    static constexpr uint32_t FDCAN_CCCR_CSA = 0x8;     // CSA
    static constexpr uint32_t FDCAN_CCCR_CSR = 0x10;    // CSR
    static constexpr uint32_t FDCAN_CCCR_MON = 0x20;    // MON
    static constexpr uint32_t FDCAN_CCCR_DAR = 0x40;    // DAR
    static constexpr uint32_t FDCAN_CCCR_TEST = 0x80;   // TEST
    static constexpr uint32_t FDCAN_CCCR_FDOE = 0x100;  // FDOE
    static constexpr uint32_t FDCAN_CCCR_BRSE = 0x200;  // BRSE
    static constexpr uint32_t FDCAN_CCCR_PXHD = 0x1000; // PXHD
    static constexpr uint32_t FDCAN_CCCR_EFBI = 0x2000; // EFBI
    static constexpr uint32_t FDCAN_CCCR_TXP = 0x4000;  // TXP
    static constexpr uint32_t FDCAN_CCCR_NISO = 0x8000; // NISO

    static constexpr uint32_t FDCAN_NBTP_RESET_VALUE = 0xa33;
    template<uint32_t X>
    static constexpr uint32_t FDCAN_NBTP_NTSEG2 =   // NTSEG2
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_NBTP_NTSEG1 =   // NTSEG1
        bit_field_t<8, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_NBTP_NBRP =     // NBRP
        bit_field_t<16, 0x1ff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_NBTP_NSJW =     // NSJW
        bit_field_t<25, 0x7f>::value<X>();

    static constexpr uint32_t FDCAN_TSCC_RESET_VALUE = 0x0;
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TSCC_TSS =   // TSS
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TSCC_TCP =   // TCP
        bit_field_t<16, 0xf>::value<X>();

    static constexpr uint32_t FDCAN_TSCV_RESET_VALUE = 0x0;
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TSCV_TSC =   // TSC
        bit_field_t<0, 0xffff>::value<X>();

    static constexpr uint32_t FDCAN_TOCC_RESET_VALUE = 0xffff0000;
    static constexpr uint32_t FDCAN_TOCC_ETOC = 0x1; // ETOC
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TOCC_TOS =       // TOS
        bit_field_t<1, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TOCC_TOP =       // TOP
        bit_field_t<16, 0xffff>::value<X>();

    static constexpr uint32_t FDCAN_TOCV_RESET_VALUE = 0xffff;
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TOCV_TOC =   // TOC
        bit_field_t<0, 0xffff>::value<X>();

    static constexpr uint32_t FDCAN_ECR_RESET_VALUE = 0x0;
    template<uint32_t X>
    static constexpr uint32_t FDCAN_ECR_TEC =        // TEC
        bit_field_t<0, 0xff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_ECR_TREC =       // TREC
        bit_field_t<8, 0x7f>::value<X>();
    static constexpr uint32_t FDCAN_ECR_RP = 0x8000; // RP
    template<uint32_t X>
    static constexpr uint32_t FDCAN_ECR_CEL =        // CEL
        bit_field_t<16, 0xff>::value<X>();

    static constexpr uint32_t FDCAN_PSR_RESET_VALUE = 0x707;
    template<uint32_t X>
    static constexpr uint32_t FDCAN_PSR_LEC =          // LEC
        bit_field_t<0, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_PSR_ACT =          // ACT
        bit_field_t<3, 0x3>::value<X>();
    static constexpr uint32_t FDCAN_PSR_EP = 0x20;     // EP
    static constexpr uint32_t FDCAN_PSR_EW = 0x40;     // EW
    static constexpr uint32_t FDCAN_PSR_BO = 0x80;     // BO
    template<uint32_t X>
    static constexpr uint32_t FDCAN_PSR_DLEC =         // DLEC
        bit_field_t<8, 0x7>::value<X>();
    static constexpr uint32_t FDCAN_PSR_RESI = 0x800;  // RESI
    static constexpr uint32_t FDCAN_PSR_RBRS = 0x1000; // RBRS
    static constexpr uint32_t FDCAN_PSR_REDL = 0x2000; // REDL
    static constexpr uint32_t FDCAN_PSR_PXE = 0x4000;  // PXE
    template<uint32_t X>
    static constexpr uint32_t FDCAN_PSR_TDCV =         // TDCV
        bit_field_t<16, 0x7f>::value<X>();

    static constexpr uint32_t FDCAN_TDCR_RESET_VALUE = 0x0;
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TDCR_TDCF =   // TDCF
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TDCR_TDCO =   // TDCO
        bit_field_t<8, 0x7f>::value<X>();

    static constexpr uint32_t FDCAN_IR_RESET_VALUE = 0x0;
    static constexpr uint32_t FDCAN_IR_RF0N = 0x1;       // RF0N
    static constexpr uint32_t FDCAN_IR_RF0W = 0x2;       // RF0W
    static constexpr uint32_t FDCAN_IR_RF0F = 0x4;       // RF0F
    static constexpr uint32_t FDCAN_IR_RF0L = 0x8;       // RF0L
    static constexpr uint32_t FDCAN_IR_RF1N = 0x10;      // RF1N
    static constexpr uint32_t FDCAN_IR_RF1W = 0x20;      // RF1W
    static constexpr uint32_t FDCAN_IR_RF1F = 0x40;      // RF1F
    static constexpr uint32_t FDCAN_IR_RF1L = 0x80;      // RF1L
    static constexpr uint32_t FDCAN_IR_HPM = 0x100;      // HPM
    static constexpr uint32_t FDCAN_IR_TC = 0x200;       // TC
    static constexpr uint32_t FDCAN_IR_TCF = 0x400;      // TCF
    static constexpr uint32_t FDCAN_IR_TFE = 0x800;      // TFE
    static constexpr uint32_t FDCAN_IR_TEFN = 0x1000;    // TEFN
    static constexpr uint32_t FDCAN_IR_TEFW = 0x2000;    // TEFW
    static constexpr uint32_t FDCAN_IR_TEFF = 0x4000;    // TEFF
    static constexpr uint32_t FDCAN_IR_TEFL = 0x8000;    // TEFL
    static constexpr uint32_t FDCAN_IR_TSW = 0x10000;    // TSW
    static constexpr uint32_t FDCAN_IR_MRAF = 0x20000;   // MRAF
    static constexpr uint32_t FDCAN_IR_TOO = 0x40000;    // TOO
    static constexpr uint32_t FDCAN_IR_DRX = 0x80000;    // DRX
    static constexpr uint32_t FDCAN_IR_ELO = 0x400000;   // ELO
    static constexpr uint32_t FDCAN_IR_EP = 0x800000;    // EP
    static constexpr uint32_t FDCAN_IR_EW = 0x1000000;   // EW
    static constexpr uint32_t FDCAN_IR_BO = 0x2000000;   // BO
    static constexpr uint32_t FDCAN_IR_WDI = 0x4000000;  // WDI
    static constexpr uint32_t FDCAN_IR_PEA = 0x8000000;  // PEA
    static constexpr uint32_t FDCAN_IR_PED = 0x10000000; // PED
    static constexpr uint32_t FDCAN_IR_ARA = 0x20000000; // ARA

    static constexpr uint32_t FDCAN_IE_RESET_VALUE = 0x0;
    static constexpr uint32_t FDCAN_IE_RF0NE = 0x1;       // RF0NE
    static constexpr uint32_t FDCAN_IE_RF0WE = 0x2;       // RF0WE
    static constexpr uint32_t FDCAN_IE_RF0FE = 0x4;       // RF0FE
    static constexpr uint32_t FDCAN_IE_RF0LE = 0x8;       // RF0LE
    static constexpr uint32_t FDCAN_IE_RF1NE = 0x10;      // RF1NE
    static constexpr uint32_t FDCAN_IE_RF1WE = 0x20;      // RF1WE
    static constexpr uint32_t FDCAN_IE_RF1FE = 0x40;      // RF1FE
    static constexpr uint32_t FDCAN_IE_RF1LE = 0x80;      // RF1LE
    static constexpr uint32_t FDCAN_IE_HPME = 0x100;      // HPME
    static constexpr uint32_t FDCAN_IE_TCE = 0x200;       // TCE
    static constexpr uint32_t FDCAN_IE_TCFE = 0x400;      // TCFE
    static constexpr uint32_t FDCAN_IE_TFEE = 0x800;      // TFEE
    static constexpr uint32_t FDCAN_IE_TEFNE = 0x1000;    // TEFNE
    static constexpr uint32_t FDCAN_IE_TEFWE = 0x2000;    // TEFWE
    static constexpr uint32_t FDCAN_IE_TEFFE = 0x4000;    // TEFFE
    static constexpr uint32_t FDCAN_IE_TEFLE = 0x8000;    // TEFLE
    static constexpr uint32_t FDCAN_IE_TSWE = 0x10000;    // TSWE
    static constexpr uint32_t FDCAN_IE_MRAFE = 0x20000;   // MRAFE
    static constexpr uint32_t FDCAN_IE_TOOE = 0x40000;    // TOOE
    static constexpr uint32_t FDCAN_IE_DRXE = 0x80000;    // DRXE
    static constexpr uint32_t FDCAN_IE_BECE = 0x100000;   // BECE
    static constexpr uint32_t FDCAN_IE_BEUE = 0x200000;   // BEUE
    static constexpr uint32_t FDCAN_IE_ELOE = 0x400000;   // ELOE
    static constexpr uint32_t FDCAN_IE_EPE = 0x800000;    // EPE
    static constexpr uint32_t FDCAN_IE_EWE = 0x1000000;   // EWE
    static constexpr uint32_t FDCAN_IE_BOE = 0x2000000;   // BOE
    static constexpr uint32_t FDCAN_IE_WDIE = 0x4000000;  // WDIE
    static constexpr uint32_t FDCAN_IE_PEAE = 0x8000000;  // PEAE
    static constexpr uint32_t FDCAN_IE_PEDE = 0x10000000; // PEDE
    static constexpr uint32_t FDCAN_IE_ARAE = 0x20000000; // ARAE

    static constexpr uint32_t FDCAN_ILS_RESET_VALUE = 0x0;
    static constexpr uint32_t FDCAN_ILS_RF0NL = 0x1;       // RF0NL
    static constexpr uint32_t FDCAN_ILS_RF0WL = 0x2;       // RF0WL
    static constexpr uint32_t FDCAN_ILS_RF0FL = 0x4;       // RF0FL
    static constexpr uint32_t FDCAN_ILS_RF0LL = 0x8;       // RF0LL
    static constexpr uint32_t FDCAN_ILS_RF1NL = 0x10;      // RF1NL
    static constexpr uint32_t FDCAN_ILS_RF1WL = 0x20;      // RF1WL
    static constexpr uint32_t FDCAN_ILS_RF1FL = 0x40;      // RF1FL
    static constexpr uint32_t FDCAN_ILS_RF1LL = 0x80;      // RF1LL
    static constexpr uint32_t FDCAN_ILS_HPML = 0x100;      // HPML
    static constexpr uint32_t FDCAN_ILS_TCL = 0x200;       // TCL
    static constexpr uint32_t FDCAN_ILS_TCFL = 0x400;      // TCFL
    static constexpr uint32_t FDCAN_ILS_TFEL = 0x800;      // TFEL
    static constexpr uint32_t FDCAN_ILS_TEFNL = 0x1000;    // TEFNL
    static constexpr uint32_t FDCAN_ILS_TEFWL = 0x2000;    // TEFWL
    static constexpr uint32_t FDCAN_ILS_TEFFL = 0x4000;    // TEFFL
    static constexpr uint32_t FDCAN_ILS_TEFLL = 0x8000;    // TEFLL
    static constexpr uint32_t FDCAN_ILS_TSWL = 0x10000;    // TSWL
    static constexpr uint32_t FDCAN_ILS_MRAFL = 0x20000;   // MRAFL
    static constexpr uint32_t FDCAN_ILS_TOOL = 0x40000;    // TOOL
    static constexpr uint32_t FDCAN_ILS_DRXL = 0x80000;    // DRXL
    static constexpr uint32_t FDCAN_ILS_BECL = 0x100000;   // BECL
    static constexpr uint32_t FDCAN_ILS_BEUL = 0x200000;   // BEUL
    static constexpr uint32_t FDCAN_ILS_ELOL = 0x400000;   // ELOL
    static constexpr uint32_t FDCAN_ILS_EPL = 0x800000;    // EPL
    static constexpr uint32_t FDCAN_ILS_EWL = 0x1000000;   // EWL
    static constexpr uint32_t FDCAN_ILS_BOL = 0x2000000;   // BOL
    static constexpr uint32_t FDCAN_ILS_WDIL = 0x4000000;  // WDIL
    static constexpr uint32_t FDCAN_ILS_PEAL = 0x8000000;  // PEAL
    static constexpr uint32_t FDCAN_ILS_PEDL = 0x10000000; // PEDL
    static constexpr uint32_t FDCAN_ILS_ARAL = 0x20000000; // ARAL

    static constexpr uint32_t FDCAN_ILE_RESET_VALUE = 0x0;
    static constexpr uint32_t FDCAN_ILE_EINT0 = 0x1; // EINT0
    static constexpr uint32_t FDCAN_ILE_EINT1 = 0x2; // EINT1

    static constexpr uint32_t FDCAN_GFC_RESET_VALUE = 0x0;
    static constexpr uint32_t FDCAN_GFC_RRFE = 0x1; // RRFE
    static constexpr uint32_t FDCAN_GFC_RRFS = 0x2; // RRFS
    template<uint32_t X>
    static constexpr uint32_t FDCAN_GFC_ANFE =      // ANFE
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_GFC_ANFS =      // ANFS
        bit_field_t<4, 0x3>::value<X>();

    static constexpr uint32_t FDCAN_SIDFC_RESET_VALUE = 0x0;
    template<uint32_t X>
    static constexpr uint32_t FDCAN_SIDFC_FLSSA =   // FLSSA
        bit_field_t<2, 0x3fff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_SIDFC_LSS =     // LSS
        bit_field_t<16, 0xff>::value<X>();

    static constexpr uint32_t FDCAN_XIDFC_RESET_VALUE = 0x0;
    template<uint32_t X>
    static constexpr uint32_t FDCAN_XIDFC_FLESA =   // FLESA
        bit_field_t<2, 0x3fff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_XIDFC_LSE =     // LSE
        bit_field_t<16, 0xff>::value<X>();

    static constexpr uint32_t FDCAN_XIDAM_RESET_VALUE = 0x1fffffff;
    template<uint32_t X>
    static constexpr uint32_t FDCAN_XIDAM_EIDM =   // EIDM
        bit_field_t<0, 0x1fffffff>::value<X>();

    static constexpr uint32_t FDCAN_HPMS_RESET_VALUE = 0x0;
    template<uint32_t X>
    static constexpr uint32_t FDCAN_HPMS_BIDX =         // BIDX
        bit_field_t<0, 0x3f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_HPMS_MSI =          // MSI
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_HPMS_FIDX =         // FIDX
        bit_field_t<8, 0x7f>::value<X>();
    static constexpr uint32_t FDCAN_HPMS_FLST = 0x8000; // FLST

    static constexpr uint32_t FDCAN_NDAT1_RESET_VALUE = 0x0;
    static constexpr uint32_t FDCAN_NDAT1_ND0 = 0x1;         // ND0
    static constexpr uint32_t FDCAN_NDAT1_ND1 = 0x2;         // ND1
    static constexpr uint32_t FDCAN_NDAT1_ND2 = 0x4;         // ND2
    static constexpr uint32_t FDCAN_NDAT1_ND3 = 0x8;         // ND3
    static constexpr uint32_t FDCAN_NDAT1_ND4 = 0x10;        // ND4
    static constexpr uint32_t FDCAN_NDAT1_ND5 = 0x20;        // ND5
    static constexpr uint32_t FDCAN_NDAT1_ND6 = 0x40;        // ND6
    static constexpr uint32_t FDCAN_NDAT1_ND7 = 0x80;        // ND7
    static constexpr uint32_t FDCAN_NDAT1_ND8 = 0x100;       // ND8
    static constexpr uint32_t FDCAN_NDAT1_ND9 = 0x200;       // ND9
    static constexpr uint32_t FDCAN_NDAT1_ND10 = 0x400;      // ND10
    static constexpr uint32_t FDCAN_NDAT1_ND11 = 0x800;      // ND11
    static constexpr uint32_t FDCAN_NDAT1_ND12 = 0x1000;     // ND12
    static constexpr uint32_t FDCAN_NDAT1_ND13 = 0x2000;     // ND13
    static constexpr uint32_t FDCAN_NDAT1_ND14 = 0x4000;     // ND14
    static constexpr uint32_t FDCAN_NDAT1_ND15 = 0x8000;     // ND15
    static constexpr uint32_t FDCAN_NDAT1_ND16 = 0x10000;    // ND16
    static constexpr uint32_t FDCAN_NDAT1_ND17 = 0x20000;    // ND17
    static constexpr uint32_t FDCAN_NDAT1_ND18 = 0x40000;    // ND18
    static constexpr uint32_t FDCAN_NDAT1_ND19 = 0x80000;    // ND19
    static constexpr uint32_t FDCAN_NDAT1_ND20 = 0x100000;   // ND20
    static constexpr uint32_t FDCAN_NDAT1_ND21 = 0x200000;   // ND21
    static constexpr uint32_t FDCAN_NDAT1_ND22 = 0x400000;   // ND22
    static constexpr uint32_t FDCAN_NDAT1_ND23 = 0x800000;   // ND23
    static constexpr uint32_t FDCAN_NDAT1_ND24 = 0x1000000;  // ND24
    static constexpr uint32_t FDCAN_NDAT1_ND25 = 0x2000000;  // ND25
    static constexpr uint32_t FDCAN_NDAT1_ND26 = 0x4000000;  // ND26
    static constexpr uint32_t FDCAN_NDAT1_ND27 = 0x8000000;  // ND27
    static constexpr uint32_t FDCAN_NDAT1_ND28 = 0x10000000; // ND28
    static constexpr uint32_t FDCAN_NDAT1_ND29 = 0x20000000; // ND29
    static constexpr uint32_t FDCAN_NDAT1_ND30 = 0x40000000; // ND30
    static constexpr uint32_t FDCAN_NDAT1_ND31 = 0x80000000; // ND31

    static constexpr uint32_t FDCAN_NDAT2_RESET_VALUE = 0x0;
    static constexpr uint32_t FDCAN_NDAT2_ND32 = 0x1;        // ND32
    static constexpr uint32_t FDCAN_NDAT2_ND33 = 0x2;        // ND33
    static constexpr uint32_t FDCAN_NDAT2_ND34 = 0x4;        // ND34
    static constexpr uint32_t FDCAN_NDAT2_ND35 = 0x8;        // ND35
    static constexpr uint32_t FDCAN_NDAT2_ND36 = 0x10;       // ND36
    static constexpr uint32_t FDCAN_NDAT2_ND37 = 0x20;       // ND37
    static constexpr uint32_t FDCAN_NDAT2_ND38 = 0x40;       // ND38
    static constexpr uint32_t FDCAN_NDAT2_ND39 = 0x80;       // ND39
    static constexpr uint32_t FDCAN_NDAT2_ND40 = 0x100;      // ND40
    static constexpr uint32_t FDCAN_NDAT2_ND41 = 0x200;      // ND41
    static constexpr uint32_t FDCAN_NDAT2_ND42 = 0x400;      // ND42
    static constexpr uint32_t FDCAN_NDAT2_ND43 = 0x800;      // ND43
    static constexpr uint32_t FDCAN_NDAT2_ND44 = 0x1000;     // ND44
    static constexpr uint32_t FDCAN_NDAT2_ND45 = 0x2000;     // ND45
    static constexpr uint32_t FDCAN_NDAT2_ND46 = 0x4000;     // ND46
    static constexpr uint32_t FDCAN_NDAT2_ND47 = 0x8000;     // ND47
    static constexpr uint32_t FDCAN_NDAT2_ND48 = 0x10000;    // ND48
    static constexpr uint32_t FDCAN_NDAT2_ND49 = 0x20000;    // ND49
    static constexpr uint32_t FDCAN_NDAT2_ND50 = 0x40000;    // ND50
    static constexpr uint32_t FDCAN_NDAT2_ND51 = 0x80000;    // ND51
    static constexpr uint32_t FDCAN_NDAT2_ND52 = 0x100000;   // ND52
    static constexpr uint32_t FDCAN_NDAT2_ND53 = 0x200000;   // ND53
    static constexpr uint32_t FDCAN_NDAT2_ND54 = 0x400000;   // ND54
    static constexpr uint32_t FDCAN_NDAT2_ND55 = 0x800000;   // ND55
    static constexpr uint32_t FDCAN_NDAT2_ND56 = 0x1000000;  // ND56
    static constexpr uint32_t FDCAN_NDAT2_ND57 = 0x2000000;  // ND57
    static constexpr uint32_t FDCAN_NDAT2_ND58 = 0x4000000;  // ND58
    static constexpr uint32_t FDCAN_NDAT2_ND59 = 0x8000000;  // ND59
    static constexpr uint32_t FDCAN_NDAT2_ND60 = 0x10000000; // ND60
    static constexpr uint32_t FDCAN_NDAT2_ND61 = 0x20000000; // ND61
    static constexpr uint32_t FDCAN_NDAT2_ND62 = 0x40000000; // ND62
    static constexpr uint32_t FDCAN_NDAT2_ND63 = 0x80000000; // ND63

    static constexpr uint32_t FDCAN_RXF0C_RESET_VALUE = 0x0;
    template<uint32_t X>
    static constexpr uint32_t FDCAN_RXF0C_F0SA =             // F0SA
        bit_field_t<2, 0x3fff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_RXF0C_F0S =              // F0S
        bit_field_t<16, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_RXF0C_F0WM =             // F0WM
        bit_field_t<24, 0x7f>::value<X>();
    static constexpr uint32_t FDCAN_RXF0C_F0OM = 0x80000000; // F0OM

    static constexpr uint32_t FDCAN_RXF0S_RESET_VALUE = 0x0;
    template<uint32_t X>
    static constexpr uint32_t FDCAN_RXF0S_F0FL =            // F0FL
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_RXF0S_F0GI =            // F0GI
        bit_field_t<8, 0x3f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_RXF0S_F0PI =            // F0PI
        bit_field_t<16, 0x3f>::value<X>();
    static constexpr uint32_t FDCAN_RXF0S_F0F = 0x1000000;  // F0F
    static constexpr uint32_t FDCAN_RXF0S_RF0L = 0x2000000; // RF0L

    static constexpr uint32_t FDCAN_RXF0A_RESET_VALUE = 0x0;
    template<uint32_t X>
    static constexpr uint32_t FDCAN_RXF0A_F0AI =   // F0AI
        bit_field_t<0, 0x3f>::value<X>();

    static constexpr uint32_t FDCAN_RXBC_RESET_VALUE = 0x0;
    template<uint32_t X>
    static constexpr uint32_t FDCAN_RXBC_RBSA =   // RBSA
        bit_field_t<2, 0x3fff>::value<X>();

    static constexpr uint32_t FDCAN_RXF1C_RESET_VALUE = 0x0;
    template<uint32_t X>
    static constexpr uint32_t FDCAN_RXF1C_F1SA =             // F1SA
        bit_field_t<2, 0x3fff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_RXF1C_F1S =              // F1S
        bit_field_t<16, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_RXF1C_F1WM =             // F1WM
        bit_field_t<24, 0x7f>::value<X>();
    static constexpr uint32_t FDCAN_RXF1C_F1OM = 0x80000000; // F1OM

    static constexpr uint32_t FDCAN_RXF1S_RESET_VALUE = 0x0;
    template<uint32_t X>
    static constexpr uint32_t FDCAN_RXF1S_F1FL =            // F1FL
        bit_field_t<0, 0x7f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_RXF1S_F1GI =            // F1GI
        bit_field_t<8, 0x3f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_RXF1S_F1PI =            // F1PI
        bit_field_t<16, 0x3f>::value<X>();
    static constexpr uint32_t FDCAN_RXF1S_F1F = 0x1000000;  // F1F
    static constexpr uint32_t FDCAN_RXF1S_RF1L = 0x2000000; // RF1L
    template<uint32_t X>
    static constexpr uint32_t FDCAN_RXF1S_DMS =             // DMS
        bit_field_t<30, 0x3>::value<X>();

    static constexpr uint32_t FDCAN_RXF1A_RESET_VALUE = 0x0;
    template<uint32_t X>
    static constexpr uint32_t FDCAN_RXF1A_F1AI =   // F1AI
        bit_field_t<0, 0x3f>::value<X>();

    static constexpr uint32_t FDCAN_RXESC_RESET_VALUE = 0x0;
    template<uint32_t X>
    static constexpr uint32_t FDCAN_RXESC_F0DS =   // F0DS
        bit_field_t<0, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_RXESC_F1DS =   // F1DS
        bit_field_t<4, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_RXESC_RBDS =   // RBDS
        bit_field_t<8, 0x7>::value<X>();

    static constexpr uint32_t FDCAN_TXBC_RESET_VALUE = 0x0;
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TXBC_TBSA =             // TBSA
        bit_field_t<2, 0x3fff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TXBC_NDTB =             // NDTB
        bit_field_t<16, 0x3f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TXBC_TFQS =             // TFQS
        bit_field_t<24, 0x3f>::value<X>();
    static constexpr uint32_t FDCAN_TXBC_TFQM = 0x40000000; // TFQM

    static constexpr uint32_t FDCAN_TXFQS_RESET_VALUE = 0x0;
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TXFQS_TFFL =           // TFFL
        bit_field_t<0, 0x3f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TXFQS_TFGI =           // TFGI
        bit_field_t<8, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TXFQS_TFQPI =          // TFQPI
        bit_field_t<16, 0x1f>::value<X>();
    static constexpr uint32_t FDCAN_TXFQS_TFQF = 0x200000; // TFQF

    static constexpr uint32_t FDCAN_TXESC_RESET_VALUE = 0x0;
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TXESC_TBDS =   // TBDS
        bit_field_t<0, 0x7>::value<X>();

    static constexpr uint32_t FDCAN_TXBAR_RESET_VALUE = 0x0;

    static constexpr uint32_t FDCAN_TXBCR_RESET_VALUE = 0x0;

    static constexpr uint32_t FDCAN_TXBTO_RESET_VALUE = 0x0;

    static constexpr uint32_t FDCAN_TXBCF_RESET_VALUE = 0x0;

    static constexpr uint32_t FDCAN_TXBTIE_RESET_VALUE = 0x0;

    static constexpr uint32_t FDCAN_TXBCIE_RESET_VALUE = 0x0;

    static constexpr uint32_t FDCAN_TXEFC_RESET_VALUE = 0x0;
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TXEFC_EFSA =   // EFSA
        bit_field_t<2, 0x3fff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TXEFC_EFS =    // EFS
        bit_field_t<16, 0x3f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TXEFC_EFWM =   // EFWM
        bit_field_t<24, 0x3f>::value<X>();

    static constexpr uint32_t FDCAN_TXEFS_RESET_VALUE = 0x0;
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TXEFS_EFFL =            // EFFL
        bit_field_t<0, 0x3f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TXEFS_EFGI =            // EFGI
        bit_field_t<8, 0x1f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TXEFS_EFPI =            // EFPI
        bit_field_t<16, 0x1f>::value<X>();
    static constexpr uint32_t FDCAN_TXEFS_EFF = 0x1000000;  // EFF
    static constexpr uint32_t FDCAN_TXEFS_TEFL = 0x2000000; // TEFL

    static constexpr uint32_t FDCAN_TXEFA_RESET_VALUE = 0x0;
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TXEFA_EFAI =   // EFAI
        bit_field_t<0, 0x1f>::value<X>();

    static constexpr uint32_t FDCAN_TTTMC_RESET_VALUE = 0x0;
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TTTMC_TMSA =   // TMSA
        bit_field_t<2, 0x3fff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TTTMC_TME =    // TME
        bit_field_t<16, 0x7f>::value<X>();

    static constexpr uint32_t FDCAN_TTRMC_RESET_VALUE = 0x0;
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TTRMC_RID =              // RID
        bit_field_t<0, 0x1fffffff>::value<X>();
    static constexpr uint32_t FDCAN_TTRMC_XTD = 0x40000000;  // XTD
    static constexpr uint32_t FDCAN_TTRMC_RMPS = 0x80000000; // RMPS

    static constexpr uint32_t FDCAN_TTOCF_RESET_VALUE = 0x10000;
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TTOCF_OM =              // OM
        bit_field_t<0, 0x3>::value<X>();
    static constexpr uint32_t FDCAN_TTOCF_GEN = 0x8;        // GEN
    static constexpr uint32_t FDCAN_TTOCF_TM = 0x10;        // TM
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TTOCF_LDSDL =           // LDSDL
        bit_field_t<5, 0x7>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TTOCF_IRTO =            // IRTO
        bit_field_t<8, 0x7f>::value<X>();
    static constexpr uint32_t FDCAN_TTOCF_EECS = 0x8000;    // EECS
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TTOCF_AWL =             // AWL
        bit_field_t<16, 0xff>::value<X>();
    static constexpr uint32_t FDCAN_TTOCF_EGTF = 0x1000000; // EGTF
    static constexpr uint32_t FDCAN_TTOCF_ECC = 0x2000000;  // ECC
    static constexpr uint32_t FDCAN_TTOCF_EVTP = 0x4000000; // EVTP

    static constexpr uint32_t FDCAN_TTMLM_RESET_VALUE = 0x0;
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TTMLM_CCM =    // CCM
        bit_field_t<0, 0x3f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TTMLM_CSS =    // CSS
        bit_field_t<6, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TTMLM_TXEW =   // TXEW
        bit_field_t<8, 0xf>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TTMLM_ENTT =   // ENTT
        bit_field_t<16, 0xfff>::value<X>();

    static constexpr uint32_t FDCAN_TURCF_RESET_VALUE = 0x0;
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TURCF_NCL =             // NCL
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TURCF_DC =              // DC
        bit_field_t<16, 0x3fff>::value<X>();
    static constexpr uint32_t FDCAN_TURCF_ELT = 0x80000000; // ELT

    static constexpr uint32_t FDCAN_TTOCN_RESET_VALUE = 0x0;
    static constexpr uint32_t FDCAN_TTOCN_SGT = 0x1;     // SGT
    static constexpr uint32_t FDCAN_TTOCN_ECS = 0x2;     // ECS
    static constexpr uint32_t FDCAN_TTOCN_SWP = 0x4;     // SWP
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TTOCN_SWS =          // SWS
        bit_field_t<3, 0x3>::value<X>();
    static constexpr uint32_t FDCAN_TTOCN_RTIE = 0x20;   // RTIE
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TTOCN_TMC =          // TMC
        bit_field_t<6, 0x3>::value<X>();
    static constexpr uint32_t FDCAN_TTOCN_TTIE = 0x100;  // TTIE
    static constexpr uint32_t FDCAN_TTOCN_GCS = 0x200;   // GCS
    static constexpr uint32_t FDCAN_TTOCN_FGP = 0x400;   // FGP
    static constexpr uint32_t FDCAN_TTOCN_TMG = 0x800;   // TMG
    static constexpr uint32_t FDCAN_TTOCN_NIG = 0x1000;  // NIG
    static constexpr uint32_t FDCAN_TTOCN_ESCN = 0x2000; // ESCN
    static constexpr uint32_t FDCAN_TTOCN_LCKC = 0x8000; // LCKC

    static constexpr uint32_t FDCAN_TTGTP_RESET_VALUE = 0x0;
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TTGTP_TP =    // TP
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TTGTP_CTP =   // CTP
        bit_field_t<16, 0xffff>::value<X>();

    static constexpr uint32_t FDCAN_TTTMK_RESET_VALUE = 0x0;
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TTTMK_TM =               // TM
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TTTMK_TICC =             // TICC
        bit_field_t<16, 0x7f>::value<X>();
    static constexpr uint32_t FDCAN_TTTMK_LCKM = 0x80000000; // LCKM

    static constexpr uint32_t FDCAN_TTIR_RESET_VALUE = 0x0;
    static constexpr uint32_t FDCAN_TTIR_SBC = 0x1;     // SBC
    static constexpr uint32_t FDCAN_TTIR_SMC = 0x2;     // SMC
    static constexpr uint32_t FDCAN_TTIR_CSM = 0x4;     // CSM
    static constexpr uint32_t FDCAN_TTIR_SOG = 0x8;     // SOG
    static constexpr uint32_t FDCAN_TTIR_RTMI = 0x10;   // RTMI
    static constexpr uint32_t FDCAN_TTIR_TTMI = 0x20;   // TTMI
    static constexpr uint32_t FDCAN_TTIR_SWE = 0x40;    // SWE
    static constexpr uint32_t FDCAN_TTIR_GTW = 0x80;    // GTW
    static constexpr uint32_t FDCAN_TTIR_GTD = 0x100;   // GTD
    static constexpr uint32_t FDCAN_TTIR_GTE = 0x200;   // GTE
    static constexpr uint32_t FDCAN_TTIR_TXU = 0x400;   // TXU
    static constexpr uint32_t FDCAN_TTIR_TXO = 0x800;   // TXO
    static constexpr uint32_t FDCAN_TTIR_SE1 = 0x1000;  // SE1
    static constexpr uint32_t FDCAN_TTIR_SE2 = 0x2000;  // SE2
    static constexpr uint32_t FDCAN_TTIR_ELC = 0x4000;  // ELC
    static constexpr uint32_t FDCAN_TTIR_IWTG = 0x8000; // IWTG
    static constexpr uint32_t FDCAN_TTIR_WT = 0x10000;  // WT
    static constexpr uint32_t FDCAN_TTIR_AW = 0x20000;  // AW
    static constexpr uint32_t FDCAN_TTIR_CER = 0x40000; // CER

    static constexpr uint32_t FDCAN_TTIE_RESET_VALUE = 0x0;
    static constexpr uint32_t FDCAN_TTIE_SBCE = 0x1;     // SBCE
    static constexpr uint32_t FDCAN_TTIE_SMCE = 0x2;     // SMCE
    static constexpr uint32_t FDCAN_TTIE_CSME = 0x4;     // CSME
    static constexpr uint32_t FDCAN_TTIE_SOGE = 0x8;     // SOGE
    static constexpr uint32_t FDCAN_TTIE_RTMIE = 0x10;   // RTMIE
    static constexpr uint32_t FDCAN_TTIE_TTMIE = 0x20;   // TTMIE
    static constexpr uint32_t FDCAN_TTIE_SWEE = 0x40;    // SWEE
    static constexpr uint32_t FDCAN_TTIE_GTWE = 0x80;    // GTWE
    static constexpr uint32_t FDCAN_TTIE_GTDE = 0x100;   // GTDE
    static constexpr uint32_t FDCAN_TTIE_GTEE = 0x200;   // GTEE
    static constexpr uint32_t FDCAN_TTIE_TXUE = 0x400;   // TXUE
    static constexpr uint32_t FDCAN_TTIE_TXOE = 0x800;   // TXOE
    static constexpr uint32_t FDCAN_TTIE_SE1E = 0x1000;  // SE1E
    static constexpr uint32_t FDCAN_TTIE_SE2E = 0x2000;  // SE2E
    static constexpr uint32_t FDCAN_TTIE_ELCE = 0x4000;  // ELCE
    static constexpr uint32_t FDCAN_TTIE_IWTE = 0x8000;  // IWTE
    static constexpr uint32_t FDCAN_TTIE_WTE = 0x10000;  // WTE
    static constexpr uint32_t FDCAN_TTIE_AWE = 0x20000;  // AWE
    static constexpr uint32_t FDCAN_TTIE_CERE = 0x40000; // CERE

    static constexpr uint32_t FDCAN_TTILS_RESET_VALUE = 0x0;
    static constexpr uint32_t FDCAN_TTILS_SBCL = 0x1;     // SBCL
    static constexpr uint32_t FDCAN_TTILS_SMCL = 0x2;     // SMCL
    static constexpr uint32_t FDCAN_TTILS_CSML = 0x4;     // CSML
    static constexpr uint32_t FDCAN_TTILS_SOGL = 0x8;     // SOGL
    static constexpr uint32_t FDCAN_TTILS_RTMIL = 0x10;   // RTMIL
    static constexpr uint32_t FDCAN_TTILS_TTMIL = 0x20;   // TTMIL
    static constexpr uint32_t FDCAN_TTILS_SWEL = 0x40;    // SWEL
    static constexpr uint32_t FDCAN_TTILS_GTWL = 0x80;    // GTWL
    static constexpr uint32_t FDCAN_TTILS_GTDL = 0x100;   // GTDL
    static constexpr uint32_t FDCAN_TTILS_GTEL = 0x200;   // GTEL
    static constexpr uint32_t FDCAN_TTILS_TXUL = 0x400;   // TXUL
    static constexpr uint32_t FDCAN_TTILS_TXOL = 0x800;   // TXOL
    static constexpr uint32_t FDCAN_TTILS_SE1L = 0x1000;  // SE1L
    static constexpr uint32_t FDCAN_TTILS_SE2L = 0x2000;  // SE2L
    static constexpr uint32_t FDCAN_TTILS_ELCL = 0x4000;  // ELCL
    static constexpr uint32_t FDCAN_TTILS_IWTL = 0x8000;  // IWTL
    static constexpr uint32_t FDCAN_TTILS_WTL = 0x10000;  // WTL
    static constexpr uint32_t FDCAN_TTILS_AWL = 0x20000;  // AWL
    static constexpr uint32_t FDCAN_TTILS_CERL = 0x40000; // CERL

    static constexpr uint32_t FDCAN_TTOST_RESET_VALUE = 0x80;
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TTOST_EL =               // EL
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TTOST_MS =               // MS
        bit_field_t<2, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TTOST_SYS =              // SYS
        bit_field_t<4, 0x3>::value<X>();
    static constexpr uint32_t FDCAN_TTOST_QGTP = 0x40;       // QGTP
    static constexpr uint32_t FDCAN_TTOST_QCS = 0x80;        // QCS
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TTOST_RTO =              // RTO
        bit_field_t<8, 0xff>::value<X>();
    static constexpr uint32_t FDCAN_TTOST_WGTD = 0x400000;   // WGTD
    static constexpr uint32_t FDCAN_TTOST_GFI = 0x800000;    // GFI
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TTOST_TMP =              // TMP
        bit_field_t<24, 0x7>::value<X>();
    static constexpr uint32_t FDCAN_TTOST_GSI = 0x8000000;   // GSI
    static constexpr uint32_t FDCAN_TTOST_WFE = 0x10000000;  // WFE
    static constexpr uint32_t FDCAN_TTOST_AWE = 0x20000000;  // AWE
    static constexpr uint32_t FDCAN_TTOST_WECS = 0x40000000; // WECS
    static constexpr uint32_t FDCAN_TTOST_SPL = 0x80000000;  // SPL

    static constexpr uint32_t FDCAN_TURNA_RESET_VALUE = 0x0;
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TURNA_NAV =   // NAV
        bit_field_t<0, 0x3ffff>::value<X>();

    static constexpr uint32_t FDCAN_TTLGT_RESET_VALUE = 0x0;
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TTLGT_LT =   // LT
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TTLGT_GT =   // GT
        bit_field_t<16, 0xffff>::value<X>();

    static constexpr uint32_t FDCAN_TTCTC_RESET_VALUE = 0x3f0000;
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TTCTC_CT =   // CT
        bit_field_t<0, 0xffff>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TTCTC_CC =   // CC
        bit_field_t<16, 0x3f>::value<X>();

    static constexpr uint32_t FDCAN_TTCPT_RESET_VALUE = 0x0;
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TTCPT_CCV =   // CCV
        bit_field_t<0, 0x3f>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TTCPT_SWV =   // SWV
        bit_field_t<16, 0xffff>::value<X>();

    static constexpr uint32_t FDCAN_TTCSM_RESET_VALUE = 0x0;
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TTCSM_CSM =   // CSM
        bit_field_t<0, 0xffff>::value<X>();

    static constexpr uint32_t FDCAN_TTTS_RESET_VALUE = 0x0;
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TTTS_SWTDEL =   // SWTDEL
        bit_field_t<0, 0x3>::value<X>();
    template<uint32_t X>
    static constexpr uint32_t FDCAN_TTTS_EVTSEL =   // EVTSEL
        bit_field_t<4, 0x3>::value<X>();
};


template<>
struct peripheral_t<STM32MP15xxx, FDCAN1>
{
    typedef stm32mp15xxx_fdcan1_t T;
    static T& V;
};

template<>
struct peripheral_t<STM32MP15xxx, FDCAN2>
{
    typedef stm32mp15xxx_fdcan1_t T;
    static T& V;
};

using fdcan1_t = peripheral_t<mcu_svd, FDCAN1>;
using fdcan2_t = peripheral_t<mcu_svd, FDCAN2>;

template<int INST> struct fdcan_traits {};

template<> struct fdcan_traits<1>
{
    using fdcan = fdcan1_t;
    static constexpr alternate_function_t RX = FDCAN1_RX;
    static constexpr alternate_function_t TX = FDCAN1_TX;
};

template<> struct fdcan_traits<2>
{
    using fdcan = fdcan2_t;
    static constexpr alternate_function_t RX = FDCAN2_RX;
    static constexpr alternate_function_t TX = FDCAN2_TX;
};

